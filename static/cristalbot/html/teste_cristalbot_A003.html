<!DOCTYPE html>
<html lang="pt-br">
<head>
<title>CristalBot apenas com JS</title>
<meta charset="utf-8">
</head>
<body>
	<script src="/static/assetsv5/js/three.min.js"></script>
	<script src="/static/assetsv5/js/GLTFLoader.js"></script>
<script>

var renderer; //= new THREE.WebGLRenderer();
var x,  y, scene;
var listObjEmCena=[];
var geometry=[];
var material=[];
const pixel3d=10;
const largura=window.innerWidth;
const altura=window.innerHeight;

 function initMaterial(){

	const loader = new THREE.TextureLoader();
	//const urlImgTexture = loader.load('https://vvcestudio.vercel.app/static/assetsv5/img/design/3D-06.jpg');
	//textura nave
	const urlImgTexture = loader.load('https://st3.depositphotos.com/30440304/i/600/depositphotos_343055824-stock-photo-seamless-scifi-panels-futuristic-texture.jpg');
    const urlImgTextureSoloMarte = loader.load('/static/cristalbot/texturas/textSoloMartRelevo.jpg');
	const urlImgTextureRobo = loader.load('/static/cristalbot/texturas/GameTexturaNave3_espelho.jpg');
	const urlImgTextureRoboBump = loader.load('/static/cristalbot/texturas/GameTexturaNaveBump2.jpg');
	const urlImgTextureRoboLuz = loader.load('/static/cristalbot/texturas/GameTexturaNaveLuz_2.jpg');


	const listaMateriais = [
                new THREE.MeshBasicMaterial({map: urlImgTexture}),
                new THREE.MeshBasicMaterial({map: urlImgTexture}),
                new THREE.MeshBasicMaterial({map: urlImgTexture}),
                new THREE.MeshBasicMaterial({map: urlImgTexture}),
                new THREE.MeshBasicMaterial({map: urlImgTexture}),
                new THREE.MeshBasicMaterial({map: urlImgTexture})
            ];



	material[0] = new THREE.MeshLambertMaterial({ color: "rgb(255,255,255)"});
	material[1] = new THREE.MeshLambertMaterial({ color: "rgb(192,192,192)"});
	material[2] = new THREE.MeshLambertMaterial({ color: "rgb(128,128,128)"});
	material[3] = new THREE.MeshLambertMaterial({ color: "rgb(255,0,0)"});
	material[4] = new THREE.MeshLambertMaterial({ color: "rgb(158,0,0)"});
	material[5] = new THREE.MeshLambertMaterial({ color: "rgb(98,0,0)"});
	material[6] = new THREE.MeshPhongMaterial({ color: 0xffff00});
	//material[7] = new THREE.MeshLambertMaterial({map: urlImgTextureSoloMarte}); // Textura solo marte. 

	material[7] = new THREE.MeshPhongMaterial({map: urlImgTextureSoloMarte, bumpMap: urlImgTextureSoloMarte}); // Textura da rua e do terreo.
	material[7].bumpScale=0.3;

	material[7].shininess = 1; // Brilho minimo.
	material[8] = new THREE.MeshLambertMaterial({ color: "rgb(255,162,0)"});
	material[9] = new THREE.MeshLambertMaterial({ color: "rgb(176,176,0)"});
	material[10] = new THREE.MeshLambertMaterial({ color: "rgb(138,87,0)"});
	material[11] = new THREE.MeshLambertMaterial({ color: "rgb(255,0,200)"});
	material[12] = new THREE.MeshLambertMaterial({ color: "rgb(124,56,143)"});
	material[13] = new THREE.MeshLambertMaterial({ color: "rgb(0,255,42)"});
	material[14] = new THREE.MeshLambertMaterial({ color: "rgb(0,117,20)"});
	material[15] = new THREE.MeshLambertMaterial({ color: "rgb(0,138,135)"});
	material[16] = new THREE.MeshLambertMaterial({ color: "rgb(0,0,255)"});
	material[17] = new THREE.MeshLambertMaterial({ color: "rgb(0,0,125)"});


	//emissiveMap = urlImgTextureRoboLuz
	//lightMap = urlImgTextureRoboLuz
	//specularMap?
	//emissive ?
	//aoMap: urlImgTextureRoboLuz
	//map: urlImgTextureRobo,
	//bumpMap: urlImgTextureRoboBump,

//displacementMap

	//material[18] = new THREE.MeshPhongMaterial({map: urlImgTextureRobo, lightMap: urlImgTextureRoboLuz, bumpMap: urlImgTextureRoboBump}); // Textura da rua e do terreo.
	material[18] = new THREE.MeshPhongMaterial({ 
		map: urlImgTextureRobo,
		bumpMap: urlImgTextureRoboBump,
		specular: 0x010101,
		emissive: 0xffffff,
		emissiveMap: urlImgTextureRoboLuz
	}); // Textura da rua e do terreo.
	material[18].bumpScale=0.3; // intencidade do profundidade
	material[18].shininess=100; // Brilho máximo.
	//material[18].emissiveIntensity = 1// Intensity of the emissive light. Modulates the emissive color. Default is 1.
	//material[18].lightMapIntensity = 100; // Intensity do mapa de  luz. Default is 1.

	//material[18].aoMapIntensity = 0.5;
	

/*
    material[0] = new THREE.MeshLambertMaterial({ color: "rgb(255,255,255)"});
	material[1] = new THREE.MeshLambertMaterial({ color: "rgb(192,192,192)"});
	material[2] = new THREE.MeshLambertMaterial({ color: "rgb(128,128,128)"});
	material[3] = new THREE.MeshLambertMaterial({ color: "rgb(255,0,0)"});
	material[4] = new THREE.MeshLambertMaterial({ color: "rgb(158,0,0)"});
	material[5] = new THREE.MeshLambertMaterial({ color: "rgb(98,0,0)"});
	material[6] = new THREE.MeshLambertMaterial({ color: "rgb(255,255,0)"});
	material[7] = new THREE.MeshLambertMaterial({ color: "rgb(176,176,0)"});
	material[8] = new THREE.MeshLambertMaterial({ color: "rgb(255,162,0)"});
	material[9] = new THREE.MeshLambertMaterial({ color: "rgb(176,176,0)"});
    
	const loader = new THREE.TextureLoader();  
	//const urlImgTexture = loader.load('https://vvcestudio.vercel.app/static/assetsv5/img/design/3D-06.jpg');
	//textura nave
	const urlImgTexture = loader.load('https://st3.depositphotos.com/30440304/i/600/depositphotos_343055824-stock-photo-seamless-scifi-panels-futuristic-texture.jpg');
    const listaMateriais = [
            new THREE.MeshBasicMaterial({map: urlImgTexture}),
            new THREE.MeshBasicMaterial({map: urlImgTexture}),
            new THREE.MeshBasicMaterial({map: urlImgTexture}),
            new THREE.MeshBasicMaterial({map: urlImgTexture}),
            new THREE.MeshBasicMaterial({map: urlImgTexture}),
            new THREE.MeshBasicMaterial({map: urlImgTexture})
        ];
			
    const urlImgTextureHome = loader.load('https://vvcestudio.com.br/static/metavvc/texturas/textura_home_02.jpg');
    const urlImgTextureTutorial = loader.load('https://vvcestudio.com.br/static/metavvc/texturas/textura_tutorial_02.jpg');
    const urlImgTextureJogo = loader.load('https://vvcestudio.com.br/static/metavvc/texturas/textura_jogos_02.JPG');
    const urlImgTextureEu = loader.load('https://vvcestudio.com.br/static/metavvc/texturas/textura_eu_outubro_2.jpg'); // textura_eu_02.jpg
    const urlImgTextureUtil = loader.load('https://vvcestudio.com.br/static/metavvc/texturas/textura_utilitario_2.jpg');
    const urlImgTextureDesign = loader.load('https://vvcestudio.com.br/static/metavvc/texturas/textura_design_01.jpg');
    const urlImgTextureElevador = loader.load('https://vvcestudio.com.br/static/metavvc/texturas/textura_elevador02.jpg');
    const urlImgTextureMatrix = loader.load('https://vvcestudio.com.br/static/metavvc/texturas/matrix3.png');

    material[10] = new THREE.MeshBasicMaterial({map: urlImgTextureMatrix}); // Textura Matrix
    material[11] = new THREE.MeshLambertMaterial({map: urlImgTextureDesign}); // Textura design
    material[12] = new THREE.MeshBasicMaterial({map: urlImgTextureUtil}); // Textura de Diretor.
    material[13] = new THREE.MeshBasicMaterial({map: urlImgTextureEu}); // Textura de Diretor.
    material[14] = new THREE.MeshLambertMaterial({map: urlImgTextureElevador}); // Textura de Elevador.
    material[15] = new THREE.MeshBasicMaterial({map: urlImgTextureJogo}); // Textura da sala de jogos.
    material[16] = new THREE.MeshLambertMaterial({map: urlImgTextureTutorial}); // Textura da biblioteca.
    material[17] = new THREE.MeshBasicMaterial({map: urlImgTextureHome}); // Textura da rua e do terreo. 
	
	material[18] = [
			listaMateriais[0],
			listaMateriais[1],
			listaMateriais[2],
			listaMateriais[3],
			listaMateriais[4],
			listaMateriais[5]
        ];
	*/
			
  }



function initLight(){

	///=luz=AMBIENTE===========================================================
	scene.add(new THREE.AmbientLight( 0xffffff, 0.1));

	///=luz=DirecionaL=1===========================================================
	const luz1 = new THREE.DirectionalLight( 0xffffff, 1 ); //DirectionalLight( color, intensity)
	//luz1[2] = new THREE.DirectionalLight("rgb(255,255,255)");
	//luz1[2] = new THREE.DirectionalLight()
	luz1.position.x = 500;
	luz1.position.y = 150;
	luz1.position.z = 100;
	luz1.castShadow = true // Abilitar as sombra

	//castShadow
	//Se definido como true, lançará sombras dinâmicas.
	//Aviso: Isso é caro e requer ajustes para que as sombras pareçam corretas.
	//Consulte o DirectionalLightShadow para obter detalhes.
	//O padrão é falso.

	//luz1.shadow.mapSize.width = 1500;
	//luz1.shadow.mapSize.height = 1500;
	//luz1.shadow.camera.near = 0.0;
	//luz1.shadow.camera.far = 1000;
	scene.add(luz1);

	// Criar um helper da luz
	//const helperLuz = new THREE.DirectionalLightHelper( luz1, 500 );
	const helperLuz = new THREE.CameraHelper(luz1.shadow.camera)
	scene.add(helperLuz);


	/*
	///=luz=dIRECIONAL=2============================================================
	var luz2 = new THREE.DirectionalLight( 0x0000ff, 0.5 ); //DirectionalLight( color, intensity)
	//luz1[2] = new THREE.DirectionalLight("rgb(255,255,255)");
	//luz1[2] = new THREE.DirectionalLight()
	luz2.position.x = -500;
	luz2.position.y = 150;
	luz2.position.z = 100;
	luz2.castShadow = true // Sombra
	luz2.shadow.mapSize.width = 1500;
	luz2.shadow.mapSize.height = 1500;
	luz2.shadow.camera.near = 0.0;
	luz2.shadow.camera.far = 1000;
	scene.add(luz2);

	// Criar um helper da luz
	const helperLuz2 = new THREE.DirectionalLightHelper( luz2, 500 );
	//const helperLuz2 = new THREE.CameraHelper(luz1.shadow.camera)
	scene.add(helperLuz2);
	*/
}

function initCamera(){
	// Camera
	listObjEmCena[0] = new THREE.PerspectiveCamera( 50, largura / altura, 1, pixel3d*10000 );
	scene.add(listObjEmCena[0]);
	listObjEmCena[0].position.x = -80;
	listObjEmCena[0].position.y = 80;
	listObjEmCena[0].position.z = 280;
	listObjEmCena[0].lookAt(2, 9,-21);

	//listObjEmCena[0].rotation.x = -0.45;
	//listObjEmCena[0].rotation.y = -0.45;
	//listObjEmCena[0].rotation.z = -0.24;
	// Criar um target para a camera. controls.target.set()
}


function initSolidos(){
	//=Chao==============================================================
	geometry[1] = new THREE.BoxGeometry(500,5,500);
	listObjEmCena[1] = new THREE.Mesh( geometry[1], material[7] );
	listObjEmCena[1].position.x = -6;
	listObjEmCena[1].position.y = -10;
	listObjEmCena[1].position.z = -3;
	listObjEmCena[1].receiveShadow = true; // Sombra
	//listObjEmCena[1].castShadow = true; // gerar sombra em outros objetos
	scene.add(listObjEmCena[1]);

	// =Objeto==============================================================
	geometry[2] = new THREE.BoxGeometry(15,50,15);
	listObjEmCena[2] = new THREE.Mesh( geometry[2], material[7] );
	listObjEmCena[2].position.x = -150;
	listObjEmCena[2].position.y = 25;
	listObjEmCena[2].receiveShadow = true; // Sombra. Se o material recebe sombras. O padrão é falso.
	listObjEmCena[2].castShadow = true; // gerar sombra em outros objetos. Se o objeto é renderizado no mapa de sombras. O padrão é falso.
	scene.add(listObjEmCena[2]);

	// =Objeto==============================================================
	geometry[3] = new THREE.BoxGeometry(15,50,15);
	listObjEmCena[3] = new THREE.Mesh( geometry[3], material[7] );
	listObjEmCena[3].position.x = -98;
	listObjEmCena[3].position.y = 25;
	//listObjEmCena[3].receiveShadow = true; // Sombra
	listObjEmCena[3].castShadow = true; // gerar sombra em outros objetos	
	scene.add(listObjEmCena[3]);

	
	// =Objeto==============================================================
	geometry[4] = new THREE.BoxGeometry(30,35,30);
	listObjEmCena[4] = new THREE.Mesh( geometry[4], material[7] );
	listObjEmCena[4].position.x = 78;
	listObjEmCena[4].position.y = 15;
	listObjEmCena[4].position.z = 0;
	//listObjEmCena[4].receiveShadow = true // mostra sombra
	listObjEmCena[4].castShadow = true; // gerar sombra em outros objetos
	scene.add(listObjEmCena[4]);

	// =Objeto==============================================================
	geometry[5] = new THREE.BoxGeometry(10,60,20);
	listObjEmCena[5] = new THREE.Mesh( geometry[5], material[7] );
	listObjEmCena[5].position.x = 32;
	listObjEmCena[5].position.y = 30;
	listObjEmCena[5].position.z = 78;
	//listObjEmCena[5].receiveShadow = true; // Sombra
	listObjEmCena[5].castShadow = true; // gerar sombra em outros objetos
	scene.add(listObjEmCena[5]);

	// =Objeto==============================================================
	geometry[6] = new THREE.BoxGeometry(10,40,10);
	listObjEmCena[6] = new THREE.Mesh( geometry[6], material[7] );
	listObjEmCena[6].position.x = -61;
	listObjEmCena[6].position.y = 20;
	listObjEmCena[6].position.z = -70;
	//listObjEmCena[6].receiveShadow = true; // Sombra
	listObjEmCena[6].castShadow = true; // gerar sombra em outros objetos
	scene.add(listObjEmCena[6]);

	// =Objeto==============================================================
	geometry[7] = new THREE.BoxGeometry(28,50,28); // Avatar
	listObjEmCena[7] = new THREE.Mesh( geometry[7], material[7] );
	listObjEmCena[7].position.x = 0;
	listObjEmCena[7].position.y = 24;
	listObjEmCena[7].position.z = 0;
	listObjEmCena[7].castShadow = true; // gerar sombra em outros objetos
	//scene.add(listObjEmCena[7]);
		
	// =Objeto==============================================================
	geometry[8] = new THREE.BoxGeometry(10,90,10);
	listObjEmCena[8] = new THREE.Mesh( geometry[8], material[7] );
	listObjEmCena[8].position.x = -39;
	listObjEmCena[8].position.y = 15;
	listObjEmCena[8].position.z = 67;
	//listObjEmCena[8].receiveShadow = true; // Sombra
	listObjEmCena[8].castShadow = true; // gerar sombra em outros objetos
	scene.add(listObjEmCena[8]);
}


function init(){


	scene = new THREE.Scene(); // Criar a cena onde tudo será incluido
	scene.background = new THREE.Color(0x001100); // Definir uma cor de fundo.

	//src="http://threejs.org/build/three.min.js"
	//script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"
	//script src="https://unpkg.com/three@0.127.0/examples/jsm/loaders/GLTFLoader.js"
	
	initMaterial();
	initLight();
	initCamera();
	initSolidos();

	renderer = new THREE.WebGLRenderer({antialias : true}); //renderer = new THREE.WebGLRenderer();
	renderer.setSize(largura,altura);
	//renderer.shadowMapEnabled = true;
	renderer.shadowMap.enabled = true //sombra
	renderer.shadowMap.type = THREE.PCFSoftShadowMap; //Sombra

	document.body.appendChild( renderer.domElement );
	document.addEventListener("keydown", keyPush);
	
	//===================================================================================
	let urlObj3Dglb = "/static/cristalbot/3d/cristalbotweb.glb";
	let loaderObj3D = new THREE.GLTFLoader();
    loaderObj3D.load( urlObj3Dglb, function ( gltf ) {	
		console.log("carregou o arquivo GLT Robo");
		 
		var todososobjetos = criaRobo(gltf);	
		listObjEmCena[10] = todososobjetos[0];
		//listObjEmCena[10].receiveShadow = true
		scene.add(listObjEmCena[10]);

		listObjEmCena[9] = todososobjetos[1];
		//listObjEmCena[9].receiveShadow = true
		scene.add(listObjEmCena[9]);

		listObjEmCena[11] = todososobjetos[2];
		//listObjEmCena[11].receiveShadow = true
		scene.add(listObjEmCena[11]);

		listObjEmCena[12] = todososobjetos[3];
		//listObjEmCena[12].receiveShadow = true
		scene.add(listObjEmCena[12]);

		//var novorobo = criaRobo2(gltf, material[5]);		
		//scene.add(novorobo);
		renderizar();
    });

};

var cristaisTerreno1 = [];
var cristaisTerreno2 = [];
var cristaisTerreno3 = [];
var cristaisNave = [];
var cristaisRobo = [];


function incluiCristais(index, local, objTemp , xtemp, ytemp, ztemp){
	if(local=="terreno1"){
		cristaisTerreno1[index] = new THREE.Group();
		cristaisTerreno1[index].add(new THREE.Mesh(objTemp[0], material[1]));
		cristaisTerreno1[index].add(new THREE.Mesh(objTemp[1], material[2]));
		cristaisTerreno1[index].add(new THREE.Mesh(objTemp[2], material[3]));
		cristaisTerreno1[index].add(new THREE.Mesh(objTemp[3], material[4]));
		cristaisTerreno1[index].add(new THREE.Mesh(objTemp[4], material[4]));
		cristaisTerreno1[index].scale.x = 10;
		cristaisTerreno1[index].scale.y = 10;
		cristaisTerreno1[index].scale.z = 10;
		cristaisTerreno1[index].position.x = xtemp;
		cristaisTerreno1[index].position.y = ytemp;
		cristaisTerreno1[index].position.z = ztemp;
		scene.add(cristaisTerreno1[index]);

	}else if(local=="terreno2"){
		cristaisTerreno2[index] = new THREE.Group();
		cristaisTerreno2[index].add(new THREE.Mesh(objTemp[0], material[1]));
		cristaisTerreno2[index].add(new THREE.Mesh(objTemp[1], material[2]));
		cristaisTerreno2[index].add(new THREE.Mesh(objTemp[2], material[3]));
		cristaisTerreno2[index].add(new THREE.Mesh(objTemp[3], material[4]));
		cristaisTerreno2[index].add(new THREE.Mesh(objTemp[4], material[4]));
		cristaisTerreno2[index].scale.x = 10;
		cristaisTerreno2[index].scale.y = 10;
		cristaisTerreno2[index].scale.z = 10;
		cristaisTerreno2[index].position.x = xtemp;
		cristaisTerreno2[index].position.y = ytemp;
		cristaisTerreno2[index].position.z = ztemp;
		scene.add(cristaisTerreno2[index]);

	} else if(local=="terreno3"){
		cristaisTerreno3[index] = new THREE.Group();
		cristaisTerreno3[index].add(new THREE.Mesh(objTemp[0], material[1]));
		cristaisTerreno3[index].add(new THREE.Mesh(objTemp[1], material[2]));
		cristaisTerreno3[index].add(new THREE.Mesh(objTemp[2], material[3]));
		cristaisTerreno3[index].add(new THREE.Mesh(objTemp[3], material[4]));
		cristaisTerreno3[index].add(new THREE.Mesh(objTemp[4], material[4]));
		cristaisTerreno3[index].scale.x = 10;
		cristaisTerreno3[index].scale.y = 10;
		cristaisTerreno3[index].scale.z = 10;
		cristaisTerreno3[index].position.x = xtemp;
		cristaisTerreno3[index].position.y = ytemp;
		cristaisTerreno3[index].position.z = ztemp;
		scene.add(cristaisTerreno3[index]);

	} else if(local=="nave"){
		cristaisNave[index] = new THREE.Group();
		cristaisNave[index].add(new THREE.Mesh(objTemp[0], material[1]));
		cristaisNave[index].add(new THREE.Mesh(objTemp[1], material[2]));
		cristaisNave[index].add(new THREE.Mesh(objTemp[2], material[3]));
		cristaisNave[index].add(new THREE.Mesh(objTemp[3], material[4]));
		cristaisNave[index].add(new THREE.Mesh(objTemp[4], material[4]));
		cristaisNave[index].scale.x = 10;
		cristaisNave[index].scale.y = 10;
		cristaisNave[index].scale.z = 10;
		moveCristalNave(index, xtemp, ytemp, ztemp)
		scene.add(cristaisNave[index]);
	} 
}





function criaRobo(objGLTF) {
	var obj = [];
	
	//const groupGLTF = new THREE.Group();
	const groupCristais = new THREE.Group();

	const groupRobo = new THREE.Group();
	groupNave = new THREE.Group();
	const groupTerreno = new THREE.Group();

	const tempGLT = [objGLTF.scene.children[0].geometry,
		objGLTF.scene.children[1].geometry,
		objGLTF.scene.children[2].geometry,
		objGLTF.scene.children[3].geometry,
		objGLTF.scene.children[4].geometry]

	incluiCristais(0, "terreno1", tempGLT, -300, -50, 900);

	//incluiCristais(0, "terreno2", tempGLT, 10, 18, 10)
	//incluiCristais(1, "terreno2", tempGLT, 20, 18, 20)

	//----------------------------------------------------
	/*
	incluiCristais(0, "terreno2", tempGLT, -300,20,-200);
	incluiCristais(1, "terreno2", tempGLT, -200,20,-200);
	incluiCristais(2, "terreno2", tempGLT, -100,20,-200);
	incluiCristais(3, "terreno2", tempGLT, 0,20,-200);
	incluiCristais(4, "terreno2", tempGLT, 100,20,-200);
	incluiCristais(5, "terreno2", tempGLT, 200,20,-200);
	incluiCristais(6, "terreno2", tempGLT, 300,20,-200);
	*/
	//----------------------------------------------------


	incluiCristais(10, "terreno2", tempGLT, 200,1,200);
	incluiCristais(11, "terreno2", tempGLT, 400,1,200);
	incluiCristais(12, "terreno2", tempGLT, 600,1,200);

	incluiCristais(0, "terreno2", tempGLT, 0,1,1);
	incluiCristais(10, "terreno2", tempGLT, 200,1,1);
	incluiCristais(11, "terreno2", tempGLT, 400,1,1);
	incluiCristais(12, "terreno2", tempGLT, 600,1,1);

	incluiCristais(9, "terreno2", tempGLT, -100,1,-200);
	incluiCristais(0, "terreno2", tempGLT, 0,1,-200);
	incluiCristais(10, "terreno2", tempGLT, 200,1,-200);
	incluiCristais(11, "terreno2", tempGLT, 400,1,-200);
	incluiCristais(12, "terreno2", tempGLT, 600,1,-200);

	incluiCristais(9, "terreno2", tempGLT, -200,1,-400);
	incluiCristais(9, "terreno2", tempGLT, -100,1,-400);
	incluiCristais(0, "terreno2", tempGLT, 0,1,-400);
	incluiCristais(10, "terreno2", tempGLT, 200,1,-400);
	incluiCristais(11, "terreno2", tempGLT, 400,1,-400);
	incluiCristais(12, "terreno2", tempGLT, 600,1,-400);


	//----------------------------------------------------
	/*
	incluiCristais(13, "terreno2", tempGLT, -300,20,200);
	incluiCristais(14, "terreno2", tempGLT, -200,20,200);
	incluiCristais(15, "terreno2", tempGLT, -100,20,200);
	incluiCristais(16, "terreno2", tempGLT, 0,20,200);
	incluiCristais(17, "terreno2", tempGLT, 100,20,200);
	incluiCristais(18, "terreno2", tempGLT, 200,20,200);
	incluiCristais(19, "terreno2", tempGLT, 300,20,200);
	*/	

	incluiCristais(0, "terreno3", tempGLT, -300,-50,-900);



	incluiCristais(0, "nave", tempGLT, -30, 0, 0);
	incluiCristais(1, "nave", tempGLT, -30, 0, -30);
	incluiCristais(2, "nave", tempGLT, -30, 0, -60);
	incluiCristais(3, "nave", tempGLT, -30, 0, -90);
	incluiCristais(4, "nave", tempGLT, -30, 0, -120);
	incluiCristais(5, "nave", tempGLT, -60, 0, 0);
	incluiCristais(6, "nave", tempGLT, -60, 0, -30);
	incluiCristais(7, "nave", tempGLT, -60, 0, -60);
	incluiCristais(8, "nave", tempGLT, -60, 0, -90);
	incluiCristais(9, "nave", tempGLT, -60, 0, -120);

	let i = 0;
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[1]); // Cristal
	groupCristais.add(obj[i++]);
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[2]); // Cristal
	groupCristais.add(obj[i++]);
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[3]); // Cristal
	groupCristais.add(obj[i++]);
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[4]); // Cristal
	groupCristais.add(obj[i++]);
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[4]); // Cristal
	groupCristais.add(obj[i++]);

	groupCristais.position.y = groupCristais.position.y+18;
	groupCristais.scale.x = 10;
	groupCristais.scale.y = 10;
	groupCristais.scale.z = 10;

	/****************************************************/
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Braço 
	obj[i].position.y = obj[i].position.y+0.1;
	//obj[i].position.x = obj[i].position.x+2;
	obj[i].position.z = obj[i].position.z+1.3;
	groupRobo.add(obj[i++]);

	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Cabeça (roda)
	obj[i].position.y = obj[i].position.y+1.7;
	//obj[i].position.z = obj[i].position.z-0.6;
	groupRobo.add(obj[i++]);
	
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Corpo
	groupRobo.add(obj[i++]);

	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Garra
	obj[i].position.y = obj[i].position.y+1.8;
	obj[i].position.z = obj[i].position.z-1;
	groupRobo.add(obj[i++]);

	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Roda
	obj[i].position.y = obj[i].position.y-1.3;
	obj[i].position.x = obj[i].position.x+1.2;
	obj[i].position.z = obj[i].position.z+0.8;
	groupRobo.add(obj[i++]);

	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Roda1
	obj[i].position.y = obj[i].position.y-1.3;
	obj[i].position.x = obj[i].position.x-1.2;
	obj[i].position.z = obj[i].position.z+0.8;
	groupRobo.add(obj[i++]);
	
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Roda2
	obj[i].position.y = obj[i].position.y-1.3;
	obj[i].position.x = obj[i].position.x-1.2;
	obj[i].position.z = obj[i].position.z-1.2;
	groupRobo.add(obj[i++]);
	
	
	/****************************************************/

	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Roda3
	obj[i].position.y = obj[i].position.y-1.3;
	obj[i].position.x = obj[i].position.x+1.2;
	obj[i].position.z = obj[i].position.z-1.2;
	groupRobo.add(obj[i++]);
	
	groupRobo.position.y = 18; //groupRobo.position.y+18;
	groupRobo.position.z = -500;
	groupRobo.scale.x = 10;
	groupRobo.scale.y = 10;
	groupRobo.scale.z = 10;
	groupRobo.selecao = [60, 180, 45]; //Largura, Altura, profundidade
	
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // ChãoNavep
	obj[i].position.y=-0.5;
	groupNave.add(obj[i++]);
	
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // parede
	
	
	let indexparede = i
	i++
	//obj[i].position.x=-20
	// 9 paredes
	
	var paredes=[];
	paredes[0]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	paredes[0].position.z = -20;
	paredes[0].position.x = -0.5;
	groupNave.add(paredes[0]);
	paredes[1]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	paredes[1].rotation.y = 1.55;
	paredes[1].position.z = -10;
	paredes[1].position.x = -9;
	groupNave.add(paredes[1]);
	paredes[2]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	paredes[2].rotation.y = -1.55;
	paredes[2].position.z = -10;
	paredes[2].position.x = 8;
	groupNave.add(paredes[2]);
	

	paredes[3]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	//paredes[3].position.z=0;
	paredes[3].position.x = -16;
	groupNave.add(paredes[3]);
	paredes[4]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	//paredes[4].position.z=0;
	paredes[4].position.x = 16;
	groupNave.add(paredes[4]);
	
	paredes[5]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	paredes[5].rotation.y = 1.55;
	paredes[5].position.z = 8;
	paredes[5].position.x = -25;

	groupNave.add(paredes[5]);
	
	paredes[6]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	paredes[6].rotation.y = 3.14;
	paredes[6].position.z = 17;
	paredes[6].position.x = -16;

	groupNave.add(paredes[6]);

	paredes[7]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	paredes[7].rotation.y = 3.14;
	paredes[7].position.z = 17;

	groupNave.add(paredes[7]);

	paredes[8]= new THREE.Mesh(objGLTF.scene.children[indexparede].geometry, material[18]); // parede
	paredes[8].rotation.y = 3.14;
	paredes[8].position.z = 17;
	paredes[8].position.x = 16;

	groupNave.add(paredes[8]);
	

	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // teto
	obj[i].position.y = obj[i].position.y+10;

	groupNave.add(obj[i++]);
	
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // Cabine
	obj[i].position.y=1;
	obj[i].position.z=-14;

	groupNave.add(obj[i++]);
	
	/*
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // porta
	obj[i].rotation.z = -1.4;
	obj[i].position.z = 10;
	obj[i].position.x = 24;
	groupNave.add(obj[i++]);
	*/
	objPortaNave = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // porta
	objPortaNave.rotation.z = -1.4;
	objPortaNave.position.z = 10;
	objPortaNave.position.x = 24;
	groupNave.add(objPortaNave);
	i=i+1

	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[18]); // tambor
	obj[i].position.y = 1;
	obj[i].position.x = 5;
	obj[i].position.z = -12;

	groupNave.add(obj[i++]);
	

	groupNave.scale.x = 10;
	groupNave.scale.y = 10;
	groupNave.scale.z = 10;
	
 	moverNave();

	groupRobo.position.x = -300;
	groupRobo.position.y = 20;
	groupRobo.position.z = 900;


	groupRobo.position.x = groupNave.position.x;
	groupRobo.position.y = groupNave.position.y;
	groupRobo.position.z = groupNave.position.z;

	//obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[7]);
	//obj[i].receiveShadow = true // Sombra
	//groupTerreno.add(obj[i++]);
	i=i+1;

	//obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[7]); // Terreno0
	//groupTerreno.add(obj[i++]);
	i=i+1;
	//obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[7]); // Terreno1
	//groupTerreno.add(obj[i++]);
	i=i+1;
	obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[7]); // TerrenoLua
	groupTerreno.add(obj[i]);
	i=i+1;
	//obj[i] = new THREE.Mesh(objGLTF.scene.children[i].geometry, material[7]); // TerrenoMarte
	//groupTerreno.add(obj[i]);
	i=i+1;

	groupTerreno.position.y = -40;
	groupTerreno.scale.x = 10;
	groupTerreno.scale.y = 10;
	groupTerreno.scale.z = 10;


	console.log(objGLTF);
	return [groupCristais, groupRobo, groupNave, groupTerreno]
}


function moveCristalNave(index, xtemp, ytemp, ztemp){
	cristaisNave[index].position.x = groupNave.position.x + xtemp;
	cristaisNave[index].position.y = groupNave.position.y + ytemp;
	cristaisNave[index].position.z = groupNave.position.z + ztemp;
}


var groupNave;
var positGroupNave=0;

var objPortaNave;
var stadPortaNave = false;

function moverNave(){
	if(positGroupNave==0){
		// Posição 1 nave:
		groupNave.position.x = -300;
		groupNave.position.y = -120;
		groupNave.position.z = 900;
		positGroupNave=1;
	} else if(positGroupNave==1) {
	// Posição 2 nave:
		groupNave.position.x = -300;
		groupNave.position.y = 20;
		groupNave.position.z = 20;
		positGroupNave=2;
	} else if(positGroupNave==2) {
		// Posição 3 nave:
		groupNave.position.x = -300;
		groupNave.position.y = -50;
		groupNave.position.z = -900;
		positGroupNave=3;
	} else{
		positGroupNave=0;
	}
	
	moveCristalNave(0, -180, 0, 40);
	moveCristalNave(1, -180, 0, 70);
	moveCristalNave(2, -180, 0, 100);
	moveCristalNave(3, -180, 0, 130);
	moveCristalNave(4, -180, 0, 160);
	moveCristalNave(5, -210, 0, 40);
	moveCristalNave(6, -210, 0, 70);
	moveCristalNave(7, -210, 0, 100);
	moveCristalNave(8, -210, 0, 130);
	moveCristalNave(9, -210, 0, 160);

	moveRoboNave(groupNave.position.x, groupNave.position.y, groupNave.position.z);

}

function moveRoboNave(varx,vary,varz){
	listObjEmCena[7].position.x = varx
	listObjEmCena[7].position.y = vary+20;
	listObjEmCena[7].position.z = varz;
	//moveRobo();

	//listObjEmCena[9].position.x = listObjEmCena[7].position.x; // Erro
	//listObjEmCena[9].position.y = listObjEmCena[7].position.y-6; // Erro
	//listObjEmCena[9].position.z = listObjEmCena[7].position.z; // Erro

	moverCamera(listObjEmCena[7].position.x, listObjEmCena[7].position.y, listObjEmCena[7].position.z);
	renderizar();
}

function abrePorta(){
	if(stadPortaNave){
		if(objPortaNave.rotation.z>-1.8)
			//Abrimndo
			objPortaNave.rotation.z = objPortaNave.rotation.z-0.1;
		else{
			stadPortaNave = false; // Porta aberta
		}		
	}else{
		if(objPortaNave.rotation.z<0)
			//Fechando
			objPortaNave.rotation.z = objPortaNave.rotation.z+0.1;
		else{
			stadPortaNave = true; // Porta fechada
		}
	}
	renderizar()
}

function renderizar(){
	//listObjEmCena[0].lookAt( listObjEmCena[7].position ); // Manter foco da camera no bloco branco
	renderer.render(scene, listObjEmCena[0]);
}


function keyPush(e) {
    //Ações do teclado.
    var varKey = e.key;
    var varkeyCode = e.keyCode
    if (varkeyCode === 37 || varkeyCode === 65 || varKey == "ArrowLeft") {
      //console.log("37=(<)esquerda / 65=a"); 
      moverPersonagem("<-");
    } else if (varkeyCode === 39 || varkeyCode === 68 || varKey == "ArrowRight") {
      //console.log("39=(>)Direita / 68=d");
      moverPersonagem("->");
    } else if (varkeyCode === 40 || varkeyCode === 83 || varKey == "ArrowDown") {
      //console.log("40=seta pra baixo / 83=s");    
      moverPersonagem("re"); //"descer"
    } else if (varkeyCode === 87 || varkeyCode === 38 || varKey == "ArrowUp") {
      //console.log("30=seta pra cima / 87=w");
      moverPersonagem("frente"); //"subir"
    } else if (varkeyCode === 82 || varKey == "r") {
      moverPersonagem("subir");	//voar/subir/pular  
    } else if (varkeyCode === 70 || varKey == "f") {
      moverPersonagem("descer"); //descer/abaixar
	} else if (varkeyCode === 32 || varKey == " ") {
	  moverPersonagem("pula"); //descer/abaixar 
	} else if (varKey == "p") {
	  abrePorta();
	} else if (varKey == "n") {
	  moverNave();
    } else{
	  console.log("varkeyCode:"+varkeyCode+" | varKey:"+varKey);
	}
	
  }
 
function colidBox2d(rect1, rect2){
  if(rect1.x+rect1.width/2 > rect2.x-rect2.width/2 &&
	rect1.x-rect1.width/2 < rect2.x+rect2.width/2 &&
	rect1.z+rect1.width/2 > rect2.y-rect2.width/2 &&
	rect1.y-rect1.width/2 < rect2.y+rect2.width/2){
	//tocou
	//console.log("tocou");
	return true;
  } 
  //não tocou
  return false;
}

function colidBox3d(rect1, rect2){
  if(rect1.x+rect1.width/2 > rect2.x-rect2.width/2 &&
	rect1.x-rect1.width/2 < rect2.x+rect2.width/2 &&
	rect1.y+rect1.height/2 > rect2.y-rect2.height/2 &&
	rect1.y-rect1.height/2 < rect2.y+rect2.height/2 &&
	rect1.z+rect1.depth/2 > rect2.z-rect2.depth/2 &&
	rect1.z-rect1.depth/2 < rect2.z+rect2.depth/2
	){
	//tocou
	//console.log("tocou");
	return true;
  } 
  //não tocou
  return false;
}

/*
function convertcolidObj(numObj) {
	console.log(listObjEmCena[numObj]);
	return {"x":listObjEmCena[numObj].position.x,
			"y":listObjEmCena[numObj].position.y,
			"z":listObjEmCena[numObj].position.z, 
			"width":listObjEmCena[numObj].geometry.parameters.width, 
			"height":listObjEmCena[numObj].geometry.parameters.height} 
}
*/

function colideForObjetos(){
	var respTocou = false;
	var Tocou = false;
	//0=camera //type: "PerspectiveCamera"
	//1=chão //type: "SpotLight"
	//2=luz //type:"Mesh"
	//geometry.type:'BoxGeometry'

	//const letPlayer = convertcolidObj(7);
	//let objatual = {};
	for (let i = 0; i < 9; i++ ) {
		if(i!==7 && listObjEmCena[i].type=="Mesh"){		
			//let objatual = listObjEmCena[i];
			//Tocou = colidBox3d(convertcolidObj(i),letPlayer);
			Tocou = colidBox3d(
				{
				"x":listObjEmCena[i].position.x,
				"y":listObjEmCena[i].position.y,
				"z":listObjEmCena[i].position.z, 
				"width":listObjEmCena[i].geometry.parameters.width, 
				"height":listObjEmCena[i].geometry.parameters.height,
				"depth":listObjEmCena[i].geometry.parameters.depth
				},
				{
				"x":listObjEmCena[7].position.x,
				"y":listObjEmCena[7].position.y,
				"z":listObjEmCena[7].position.z, 
				"width":listObjEmCena[7].geometry.parameters.width, 
				"height":listObjEmCena[7].geometry.parameters.height,
				"depth":listObjEmCena[7].geometry.parameters.depth
				}
			);
		}
		if(Tocou==true){
			respTocou = true;
			console.log("Tocou i="+i);
			i=10;
		}
	}
	console.log("respTocou="+respTocou);
	return respTocou;
}

function moverCamera(positX, positY, positZ) {
	listObjEmCena[0].position.x = positX;
	listObjEmCena[0].position.y = positY+55;
	listObjEmCena[0].position.z = positZ+200;
}

function moverPersonagem(varDirecao) {
	let velocidade = 4;
    if (varDirecao=="<-"){
		listObjEmCena[9].rotation.y = -1.55;
		listObjEmCena[7].position.x = listObjEmCena[7].position.x-velocidade;
		if(colideForObjetos()){
			listObjEmCena[7].position.x = listObjEmCena[7].position.x+velocidade;
		}
    } else if (varDirecao=="->"){
		listObjEmCena[9].rotation.y = 1.55;
		listObjEmCena[7].position.x = listObjEmCena[7].position.x+velocidade;
		if(colideForObjetos()){
			listObjEmCena[7].position.x = listObjEmCena[7].position.x-velocidade;
		}
    } else if (varDirecao=="re"){
		listObjEmCena[9].rotation.y = 0; //ok	
		listObjEmCena[7].position.z = listObjEmCena[7].position.z+velocidade;
		if(colideForObjetos()){
			listObjEmCena[7].position.z = listObjEmCena[7].position.z-velocidade;
		}
    } else if (varDirecao=="frente"){
		listObjEmCena[9].rotation.y = 3.14; //ok
		listObjEmCena[7].position.z = listObjEmCena[7].position.z-velocidade;
		if(colideForObjetos()){
			listObjEmCena[7].position.z = listObjEmCena[7].position.z+velocidade;
		}
	} else if (varDirecao=="subir"){
		listObjEmCena[7].position.y = listObjEmCena[7].position.y+velocidade;
		if(colideForObjetos()){
			listObjEmCena[7].position.y = listObjEmCena[7].position.y-velocidade;
		}
    } else if (varDirecao=="descer"){	
		listObjEmCena[7].position.y = listObjEmCena[7].position.y-velocidade;
		if(colideForObjetos()){
			listObjEmCena[7].position.y = listObjEmCena[7].position.y+velocidade;
		}
    } 
	 else if (varDirecao=="pula"){
		listObjEmCena[7].position.y = listObjEmCena[7].position.y+velocidade;
		if(colideForObjetos()){
			listObjEmCena[7].position.y = listObjEmCena[7].position.y-velocidade;
		}
    }
	
	moveRobo();
}


function moveRobo(){
	listObjEmCena[9].position.x = listObjEmCena[7].position.x;
	listObjEmCena[9].position.y = listObjEmCena[7].position.y-6;
	listObjEmCena[9].position.z = listObjEmCena[7].position.z;
	moverCamera(listObjEmCena[9].position.x, listObjEmCena[9].position.y, listObjEmCena[9].position.z);
	renderizar();
}


init()

</script>
</body>
</html>